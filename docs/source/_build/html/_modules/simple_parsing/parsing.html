
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>simple_parsing.parsing &#8212; simple-parsing 0.0.3 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for simple_parsing.parsing</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">* .. autoclass:: simple_parsing.ArgumentParser</span>
<span class="sd">    :members: add_arguments</span>
<span class="sd">    :undoc-members:</span>
<span class="sd">    :show-inheritance:</span>
<span class="sd">* .. autoclass:: simple_parsing.ConflictResolution</span>
<span class="sd">    :members:</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">docstring</span><span class="p">,</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">.wrappers</span> <span class="kn">import</span> <span class="n">DataclassWrapper</span><span class="p">,</span> <span class="n">FieldWrapper</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">Dataclass</span><span class="p">,</span> <span class="n">DataclassType</span><span class="p">,</span> <span class="n">MutableField</span>

<span class="n">Conflict</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DataclassWrapper</span><span class="p">]]</span>

<div class="viewcode-block" id="ConflictResolution"><a class="viewcode-back" href="../../index.html#simple_parsing.ConflictResolution">[docs]</a><span class="k">class</span> <span class="nc">ConflictResolution</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used to determine which action to take when adding arguments for the same dataclass in two different destinations.</span>
<span class="sd">    </span>
<span class="sd">    * NONE: Dissallow using the same dataclass in two different destinations without explicitly setting a distinct prefix for at least one of them.</span>
<span class="sd">    * EXPLICIT: When adding arguments for a dataclass that is already present, the argparse arguments for each class will use their full absolute path as a prefix.</span>
<span class="sd">    * ALWAYS_MERGE: When adding arguments for a dataclass that is already present, the arguments for the first and second destinations will be set using the same name,</span>
<span class="sd">      and the values for each will correspond to the first and second passed values, respectively.</span>
<span class="sd">      This will change the argparse type for that argument into a list of the original item type.</span>
<span class="sd">    * AUTO: Automatically deduces the shortest prefix which can be used to differentiate the arguments. </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">EXPLICIT</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ALWAYS_MERGE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">AUTO</span> <span class="o">=</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="ArgumentParser"><a class="viewcode-back" href="../../index.html#simple_parsing.ArgumentParser">[docs]</a><span class="k">class</span> <span class="nc">ArgumentParser</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclass of `argparse.ArgumentParser` which adds the `add_arguments` method,</span>
<span class="sd">    making it possible to automatically add command-line arguments for a given dataclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conflict_resolution</span><span class="p">:</span> <span class="n">ConflictResolution</span> <span class="o">=</span> <span class="n">ConflictResolution</span><span class="o">.</span><span class="n">AUTO</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;formatter_class&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;formatter_class&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">Formatter</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># the kind of prefixing mechanism to use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conflict_resolution</span> <span class="o">=</span> <span class="n">conflict_resolution</span>

        <span class="c1"># two-level dictionary that maps from (dataclass, string_prefix) -&gt; DataclassWrapper. </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DataclassWrapper</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">constructor_arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="c1"># # a set to check which arguments have been added so far.</span>
        <span class="c1"># self.added_arguments: Set[str] = set()</span>
<div class="viewcode-block" id="ArgumentParser.add_arguments"><a class="viewcode-back" href="../../index.html#simple_parsing.ArgumentParser.add_arguments">[docs]</a>    <span class="k">def</span> <span class="nf">add_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataclass</span><span class="p">:</span> <span class="n">DataclassType</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds corresponding command-line arguments for this class to the parser.</span>
<span class="sd">        </span>
<span class="sd">        :param dataclass: The dataclass for which to add fields as arguments in the parser</span>
<span class="sd">        :type dataclass: DataclassType</span>
<span class="sd">        :param dest: The destination attribute of the `argparse.Namespace` where the dataclass instance will be stored after calling `parse_args()`</span>
<span class="sd">        :type dest: str</span>
<span class="sd">        :param prefix: An optional prefix to add prepend to the names of the argparse arguments which will be generated for this dataclass. This can be useful when registering multiple distinct instances of the same dataclass. Defaults to &quot;&quot;</span>
<span class="sd">        :type prefix: str, optional</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">wrapper</span><span class="o">.</span><span class="n">dest</span> <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">                    Destination attribute </span><span class="si">{dest}</span><span class="s2"> is already used for dataclass of type </span><span class="si">{dataclass}</span><span class="s2">.</span>
<span class="s2">                    Make sure all destinations are unique.</span>
<span class="s2">                    &quot;&quot;&quot;</span><span class="p">))</span>
        <span class="n">new_wrapper</span><span class="p">:</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataclassWrapper</span><span class="p">(</span><span class="n">dataclass</span><span class="p">,</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">new_wrapper</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="n">wrapper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_register_dataclass</span><span class="p">(</span><span class="n">new_wrapper</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;added wrapper:</span><span class="se">\n</span><span class="si">{wrapper}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">parse_known_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>     
        <span class="c1"># NOTE: since the usual ArgumentParser.parse_args() calls parse_known_args, we therefore just need to overload the parse_known_args method.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_preprocessing</span><span class="p">()</span>
        <span class="n">parsed_args</span><span class="p">,</span> <span class="n">unparsed_args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">parse_known_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">namespace</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postprocessing</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">),</span> <span class="n">unparsed_args</span>

    <span class="k">def</span> <span class="nf">_register_dataclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_wrapper</span><span class="p">:</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;registers the given dataclass to be parsed later.</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            dataclass {Type[Dataclass]} -- The dataclass to register</span>
<span class="sd">            dest {str} -- a string which is to be used to  NamedTuple used to keep track of where to store the resulting instance and the number of instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering new DataclassWrapper: </span><span class="si">{new_wrapper}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">new_wrapper</span><span class="o">.</span><span class="n">dataclass</span><span class="p">][</span><span class="n">new_wrapper</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wrapper</span><span class="p">)</span>        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">new_wrapper</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">dataclass</span><span class="p">][</span><span class="n">child</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_wrapper</span>

    <span class="k">def</span> <span class="nf">_unregister_dataclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">:</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unregistering DataclassWrapper </span><span class="si">{wrapper}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">descendants</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Also Unregistering Child DataclassWrapper </span><span class="si">{child}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">:</span> <span class="n">DataclassWrapper</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">wrapper</span><span class="o">.</span><span class="n">dataclass</span><span class="p">][</span><span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">wrapper</span><span class="o">.</span><span class="n">dataclass</span><span class="p">][</span><span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">wrapper</span><span class="o">.</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">_preprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">PREPROCESSING</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_conflicts</span><span class="p">()</span>
        <span class="c1"># logger.debug(f&quot;Fixed wrappers: {self._fixed_wrappers}&quot;)</span>
        <span class="c1"># Create one argument group per dataclass type</span>
        <span class="k">for</span> <span class="n">dataclass</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding arguments for dataclass: </span><span class="si">{dataclass}</span><span class="s2"> at destinations </span><span class="si">{wrapper.destinations}</span><span class="s2">, multiple=</span><span class="si">{wrapper.multiple}</span><span class="s2">, prefix = &#39;</span><span class="si">{wrapper.prefix}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>                
                <span class="n">wrapper</span><span class="o">.</span><span class="n">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_postprocessing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parsed_args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiate the dataclasses from the parsed arguments and add them to their destination key in the namespace</span>
<span class="sd">        </span>
<span class="sd">        Arguments:</span>
<span class="sd">            parsed_args {argparse.Namespace} -- the result of calling super().parse_args()</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            argparse.Namespace -- The namespace, with the added attributes for each dataclass.</span>
<span class="sd">            TODO: Try and maybe return a nicer, typed version of parsed_args (a Namespace subclass maybe?)  </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">POST PROCESSING</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parsed args: </span><span class="si">{parsed_args}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># create the constructor arguments for each instance by consuming all the attributes from `parsed_args` </span>
        <span class="n">parsed_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_consume_constructor_arguments</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover arguments: </span><span class="si">{parsed_args}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constructor arguments:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">args_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constructor_arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{key}</span><span class="s2">: </span><span class="si">{args_dict}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_instances_in_args</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final parsed args:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">{key}</span><span class="s2">: </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="p">)</span>
           
        <span class="k">return</span> <span class="n">parsed_args</span>

    <span class="k">def</span> <span class="nf">_set_instances_in_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parsed_args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">:</span>
        
        <span class="c1"># we now have all the constructor arguments for each instance.</span>
        <span class="c1"># we can now sort out the different dependencies, and create the instances.</span>
        <span class="n">wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapper_for_every_destination</span>
        <span class="c1"># we construct the &#39;tree&#39; of dependencies from the bottom up,</span>
        <span class="c1"># starting with nodes that are children.</span>
        <span class="n">destinations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constructor_arguments</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">nesting_level</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">destination_attribute</span><span class="p">:</span> <span class="n">destination_attribute</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">destination</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">wrappers</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k_v</span><span class="p">:</span> <span class="n">k_v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nesting_level</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;wrapper name: </span><span class="si">{wrapper.attribute_name}</span><span class="s2">, destination: </span><span class="si">{destination}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">constructor</span> <span class="o">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">instantiate</span>
            <span class="n">constructor_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constructor_arguments</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span>
            <span class="c1"># create the dataclass instance.</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">constructor</span><span class="p">(</span><span class="n">constructor_args</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">destination</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">attribute_in_parent</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># if this instance is an attribute in another dataclass,</span>
                <span class="c1"># we set the value in the parent&#39;s constructor arguments</span>
                <span class="c1"># at the associated attribute to this instance.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">constructor_arguments</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">attribute_in_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>
                <span class="c1"># self.constructor_arguments.pop(destination) # remove the &#39;args dict&#39; for this child class.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting a value at attribute </span><span class="si">{attribute_in_parent}</span><span class="s2"> in parent </span><span class="si">{parent}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if this destination is a top-level attribute, we set the attribute</span>
                <span class="c1"># on the returned parsed_args.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;setting attribute &#39;</span><span class="si">{destination}</span><span class="s2">&#39; on the parsed_args to a value of </span><span class="si">{instance}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">,</span> <span class="n">destination</span><span class="p">),</span> <span class="s2">&quot;Namespace should not already have a &#39;</span><span class="si">{destination}</span><span class="s2">&#39; attribute! (namespace: </span><span class="si">{parsed_args}</span><span class="s2">) &quot;</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parsed_args</span>

    <span class="k">def</span> <span class="nf">_consume_constructor_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parsed_args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create the constructor arguments for each instance by consuming all the attributes from `parsed_args` </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            parsed_args (argparse.Namespace): the argparse.Namespace returned from super().parse_args().</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            argparse.Namespace: The namespace, without the consumed arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapper_for_every_destination</span>
        <span class="n">parsed_arg_values</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">parsed_args</span><span class="p">)</span>
        <span class="c1"># TODO: it would be cleaner if the CustomAction was working!</span>
        <span class="c1"># Here we imitate a custom action, by having the FieldWrappers be callables</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">field</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">init</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">parsed_arg_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="n">field</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>
                <span class="c1"># call the action manually.</span>
                <span class="c1"># this sets the right value in the `self.constructor_arguments` dictionary.</span>
                <span class="n">field</span><span class="p">(</span><span class="n">parser</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">parsed_args</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                
        <span class="c1">#Clean up the &#39;parsed_args&#39; by deleting all the consumed attributes.</span>
        <span class="n">deleted_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="n">deleted_values</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsed_arg_values</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">leftover_args</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">(</span><span class="o">**</span><span class="n">parsed_arg_values</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;deleted values: </span><span class="si">{deleted_values}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;leftover args: </span><span class="si">{leftover_args}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">leftover_args</span>

    <span class="k">def</span> <span class="nf">_get_conflicting_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Conflict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the dataclass, prefix, and conflicing DataclassWrappers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dataclass</span> <span class="ow">in</span> <span class="n">all_wrappers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">all_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">wrappers</span> <span class="o">=</span> <span class="n">all_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">][</span><span class="n">prefix</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrappers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span>
        <span class="k">return</span> <span class="kc">None</span>


    <span class="k">def</span> <span class="nf">_conflict_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]]]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return True whenever a conflict exists (multiple DataclassWrappers share the same dataclass and prefix.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">dataclass</span> <span class="ow">in</span> <span class="n">all_wrappers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="ow">in</span> <span class="n">all_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span> <span class="o">==</span> <span class="n">prefix</span> <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">),</span> <span class="s2">&quot;Misplaced DataclassWrapper!&quot;</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrappers</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_fix_conflicts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span>  <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]]:</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">):</span>
            <span class="n">conflict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_conflicting_group</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">conflict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">dataclass</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="o">=</span> <span class="n">conflict</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following {len(wrappers)} wrappers are in conflict, as they share the same dataclass and prefix:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(Conflict Resolution mode is </span><span class="si">{self.conflict_resolution}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conflict_resolution</span> <span class="o">==</span> <span class="n">ConflictResolution</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span>           
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;The following wrappers are in conflict, as they share the same dataclass and prefix:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">)</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;(Conflict Resolution mode is </span><span class="si">{self.conflict_resolution}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
                    
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">conflict_resolution</span> <span class="o">==</span> <span class="n">ConflictResolution</span><span class="o">.</span><span class="n">EXPLICIT</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fix_conflict_explicit</span><span class="p">(</span><span class="n">conflict</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">conflict_resolution</span> <span class="o">==</span> <span class="n">ConflictResolution</span><span class="o">.</span><span class="n">ALWAYS_MERGE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fix_conflict_merge</span><span class="p">(</span><span class="n">conflict</span><span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">conflict_resolution</span> <span class="o">==</span> <span class="n">ConflictResolution</span><span class="o">.</span><span class="n">AUTO</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fix_conflict_auto</span><span class="p">(</span><span class="n">conflict</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conflict_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">)</span>
        <span class="n">fixed_wrappers</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dataclass</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrappers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">wrapper</span> <span class="o">=</span> <span class="n">wrappers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span> <span class="o">==</span> <span class="n">prefix</span> 
                <span class="n">fixed_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">][</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span> 
        <span class="k">return</span> <span class="n">fixed_wrappers</span>

    <span class="k">def</span> <span class="nf">_fix_conflict_explicit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conflict</span><span class="p">):</span>
        <span class="c1"># logger.debug(&quot;fixing explicit conflict: &quot;, conflict)</span>
        <span class="n">dataclass</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="o">=</span> <span class="n">conflict</span>
        <span class="k">assert</span> <span class="n">prefix</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Wrappers for the same dataclass can&#39;t have the same user-set prefix when in EXPLICIT mode!&quot;</span>
        <span class="c1"># remove all wrappers for that prefix</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_dataclass</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">explicit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_dataclass</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">][</span><span class="n">prefix</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">][</span><span class="n">prefix</span><span class="p">]</span>
        <span class="c1"># remove the prefix from the dict so we don&#39;t have to deal with empty lists.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fix_conflict_auto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conflict</span><span class="p">):</span>
        <span class="c1"># logger.debug(&quot;fixing conflict: &quot;, conflict)</span>
        <span class="n">dataclass</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="o">=</span> <span class="n">conflict</span>
        <span class="n">prefixes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">wrapper</span><span class="o">.</span><span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">]</span>
        <span class="c1"># IDEA:</span>
        <span class="c1"># while the prefixes are the same, starting from the left, remove the first word.</span>
        <span class="c1"># Stop when they become different.</span>


        <span class="n">sentences</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="n">sentence</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>   
        <span class="p">}</span>
        <span class="n">index_prefixes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">i</span><span class="p">:</span> <span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;conflicting prefixes: </span><span class="si">{prefixes}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># TODO: do something here with the prefixes.</span>
        <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="n">prefixes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">:</span>
                <span class="n">first_word</span> <span class="o">=</span> <span class="n">sentence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">result</span><span class="p">[</span><span class="n">first_word</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>

            <span class="n">return_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">first_word</span><span class="p">,</span> <span class="n">sentences</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">first_word</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sentences_without_first_word</span> <span class="o">=</span> <span class="p">[</span><span class="n">sentence</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">sentence</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
                    <span class="n">return_dict</span><span class="p">[</span><span class="n">first_word</span><span class="p">]</span> <span class="o">=</span> <span class="n">differentiate</span><span class="p">(</span><span class="n">sentences_without_first_word</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">return_dict</span>

        <span class="n">prefix_dict</span> <span class="o">=</span> <span class="n">differentiate</span><span class="p">(</span><span class="n">prefixes</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Prefix dict: </span><span class="si">{prefix_dict}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dest_to_wrapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">dest</span><span class="p">:</span> <span class="n">wrapper</span> <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span> <span class="p">}</span>
        <span class="n">prefix_to_wrapper</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">dest_to_wrapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">dest</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="n">_prefix_dict</span> <span class="o">=</span> <span class="n">prefix_dict</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">_prefix_dict</span> <span class="o">=</span> <span class="n">_prefix_dict</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">_prefix_dict</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">prefix_to_wrapper</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span>
        
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">prefix_to_wrapper</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wrapper for attribute </span><span class="si">{wrapper.dest}</span><span class="s2"> has prefix &#39;</span><span class="si">{prefix}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_dataclass</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_register_dataclass</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_fix_conflict_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conflict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fix conflicts using the merging approach:</span>
<span class="sd">        The first wrapper is kept, and the rest of the wrappers are absorbed into the first wrapper.</span>

<span class="sd">        # TODO: check that the ordering of arguments is still preserved!</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            conflict ([type]): [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dataclass</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrappers</span> <span class="o">=</span> <span class="n">conflict</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">wrappers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="n">first_wrapper</span><span class="p">:</span> <span class="n">DataclassWrapper</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrappers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unregister_dataclass</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">first_wrapper</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_wrapper</span> <span class="o">=</span> <span class="n">wrapper</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first_wrapper</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
        
        <span class="k">assert</span> <span class="n">first_wrapper</span><span class="o">.</span><span class="n">multiple</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_dataclass</span><span class="p">(</span><span class="n">first_wrapper</span><span class="p">)</span>

    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_wrapper_for_every_destination</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Returns a dictionary where for every key (a destination), we return the associated DataclassWrapper.</span>
<span class="sd">        NOTE: multiple destinations can share the same DataclassWrapper instance.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, DataclassWrapper[Dataclass]] -- [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wrapper_for_destination</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DataclassWrapper</span><span class="p">[</span><span class="n">DataclassType</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">dataclass</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_wrappers</span><span class="p">[</span><span class="n">dataclass</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;prefix: &#39;</span><span class="si">{prefix}</span><span class="s2">&#39;, wrapper destinations: </span><span class="si">{wrapper.destinations}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">destinations</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">dest</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrapper_for_destination</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;There is already a wrapper for destination &#39;</span><span class="si">{dest}</span><span class="s2">&#39;: </span><span class="si">{wrapper_for_destination[dest]}</span><span class="s2">&quot;</span>
                    <span class="n">wrapper_for_destination</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">wrapper</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting a wrapper for destination </span><span class="si">{dest}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_for_destination</span></div>
        
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">simple-parsing</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/simple/simple_example.html">Simple Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/dataclasses/hyperparameters_example.html">HyperParameters Example</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Fabrice Normandin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>